Alarm 1:

1. A los 5 segundos no hace nada, pero cuando pasan 10 se imprime en pantalla "Alarm Clock"
2. No, el programa deja de ejecutarse (no espera a alarm) y aparece el mensaje "killed"
3. El proceso padre / con waitpid(...);
4. No / Si hay algun error con el alarm sí.

Alarm 2:

1. Cada 10 segundos imprime el pid (que no cambia) y los segundos de la alarma hasta llegar a los 100, pero al usar el comando -alrm salta al siguiente mensaje sin esperar los 10 segundos / No ha funcionado, ya que al usar el comando salta al siguente mensaje sin que hayan pasado realmente 10s
2. No SIGKILL y SIGSTOP no pueden tratarse
3. En el while hemos modificado la linea alarm(10):

	...
	int a = alarm(10);
	if (a != 0) write(1,"False\n",6);
	...

Alarm 3:

1. Los dos / Los pid son diferentes y en el codigo podemos ver el fork() / Hace falta usar el getpid(), pero ya está implementado en el código

Alarm 4:

1. 10 / El padre las 10 primeras y el hijo las 10 últimas / Entra en estado Zombie / Accediendo al fichero status en /proc/PID_PADRE

Waitpid:

2. Modificación: 

	...
	sprintf(buff,"Termina el proceso %d, causa: %d\n",pid,res);
	...

3. Modificación:

	...
	alarm(2);
	pid=waitpid(-1,&res,0);
	int t = alarm(0);
	sprintf(buff, "Interval: %d\n",t);
	write(1, buff, strlen(buff));
	...
